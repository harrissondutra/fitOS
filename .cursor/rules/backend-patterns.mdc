---
alwaysApply: true
description: Padrões de backend, Express, Prisma, middlewares e estrutura de API
---

# Padrões Backend

## Propósito

Estabelecer padrões para desenvolvimento backend usando Express, TypeScript, Prisma, garantindo código escalável, seguro e manutenível.

## Regras Obrigatórias

### ✅ SEMPRE Fazer

- Usar Express + TypeScript + Prisma para todas as rotas
- Separar lógica de negócio em services (não em routes)
- Criar middlewares reutilizáveis para auth, tenant, validação
- Usar validação com express-validator ou Zod
- Implementar error handling centralizado
- Logs estruturados com Winston para debugging
- Cache Redis para queries frequentes (padrão: `fitos:namespace:key`)
- Limpar dados sensíveis dos logs
- Validar entrada de dados rigorosamente
- Usar transactions para operações múltiplas relacionadas

### ❌ NUNCA Fazer

- NÃO colocar lógica de negócio em routes ou controllers
- NÃO omitir validação de entrada
- NÃO fazer queries sem filtrar por tenantId
- NÃO logar senhas, tokens ou dados sensíveis
- NÃO usar console.log (usar logger)
- NÃO esquecer de fechar conexões/cursors
- NÃO criar rotas sem rate limiting
- NÃO permitir SQL injection (usar Prisma, nunca SQL raw)

## Padrões e Exemplos

### Estrutura de Rotas RESTful

```typescript
// ✅ Estrutura padrão de rotas
// src/backend/src/routes/users.routes.ts

import { Router } from 'express';
import { UserService } from '../services/user.service';
import { authMiddleware } from '../middleware/auth.middleware';
import { tenantMiddleware } from '../middleware/tenant.middleware';
import { validateCreateUser, validateUpdateUser } from '../middleware/validation.middleware';
import { errorHandler } from '../middleware/errorHandler';

const router = Router();
const userService = new UserService();

// GET /users - Listar usuários
router.get('/users',
  authMiddleware,
  tenantMiddleware,
  async (req, res, next) => {
    try {
      const { page = 1, limit = 10, search } = req.query;
      const users = await userService.getUsers(
        req.tenantId,
        { page, limit, search }
      );
      res.json({
        success: true,
        data: users,
        pagination: {
          page,
          limit,
          total: users.length
        }
      });
    } catch (error) {
      next(error);
    }
  }
);

// GET /users/:id - Obter usuário
router.get('/users/:id',
  authMiddleware,
  tenantMiddleware,
  async (req, res, next) => {
    try {
      const user = await userService.getUserById(req.params.id, req.tenantId);
      if (!user) {
        return res.status(404).json({
          success: false,
          error: 'User not found'
        });
      }
      res.json({ success: true, data: user });
    } catch (error) {
      next(error);
    }
  }
);

// POST /users - Criar usuário
router.post('/users',
  authMiddleware,
  tenantMiddleware,
  validateCreateUser,
  async (req, res, next) => {
    try {
      const user = await userService.createUser(req.body, req.tenantId);
      res.status(201).json({ success: true, data: user });
    } catch (error) {
      next(error);
    }
  }
);

export default router;
```

### Services (Lógica de Negócio)

```typescript
// ✅ services/user.service.ts
import { PrismaClient, User } from '@prisma/client';
import { CreateUserDto, UpdateUserDto } from '../types/user.types';
import { logger } from '../utils/logger';
import { Redis } from 'ioredis';

export class UserService {
  private prisma: PrismaClient;
  private redis: Redis;

  constructor() {
    this.prisma = new PrismaClient();
    this.redis = new Redis(process.env.REDIS_URL!);
  }

  async getUsers(tenantId: string, options: {
    page: number;
    limit: number;
    search?: string;
  }): Promise<User[]> {
    logger.info('Fetching users', { tenantId, ...options });

    // Redis cache
    const cacheKey = `fitos:users:${tenantId}:${options.page}:${options.limit}`;
    const cached = await this.redis.get(cacheKey);
    
    if (cached) {
      return JSON.parse(cached);
    }

    // Query com tenantId obrigatório
    const users = await this.prisma.user.findMany({
      where: {
        tenantId,
        ...(options.search && {
          OR: [
            { name: { contains: options.search, mode: 'insensitive' } },
            { email: { contains: options.search, mode: 'insensitive' } }
          ]
        })
      },
      skip: (options.page - 1) * options.limit,
      take: options.limit,
      orderBy: { createdAt: 'desc' }
    });

    // Cache por 5 minutos
    await this.redis.setex(cacheKey, 300, JSON.stringify(users));

    return users;
  }

  async getUserById(id: string, tenantId: string): Promise<User | null> {
    logger.info('Fetching user by id', { id, tenantId });

    // SEMPRE incluir tenantId
    return await this.prisma.user.findFirst({
      where: {
        id,
        tenantId  // OBRIGATÓRIO
      }
    });
  }

  async createUser(data: CreateUserDto, tenantId: string): Promise<User> {
    logger.info('Creating user', { email: data.email, tenantId });

    // Validação
    const existingUser = await this.prisma.user.findUnique({
      where: { email: data.email }
    });

    if (existingUser) {
      throw new Error('User already exists');
    }

    // Criar com hash de senha
    const hashedPassword = await bcrypt.hash(data.password, 10);

    // Usar transaction se necessário
    const user = await this.prisma.user.create({
      data: {
        ...data,
        password: hashedPassword,
        tenantId
      }
    });

    // Invalidar cache
    await this.redis.del(`fitos:users:${tenantId}:*`);

    // Limpar dados sensíveis do retorno
    const { password, ...userWithoutPassword } = user;
    return userWithoutPassword as User;
  }

  async deleteUser(id: string, tenantId: string): Promise<void> {
    logger.info('Deleting user', { id, tenantId });

    // Soft delete
    await this.prisma.user.update({
      where: { id },
      data: { deletedAt: new Date() }
    });

    // Invalidar cache
    await this.redis.del(`fitos:users:${tenantId}:*`);
  }
}
```

### Middlewares

```typescript
// ✅ middleware/auth.middleware.ts
import { Request, Response, NextFunction } from 'express';
import { verify } from 'jsonwebtoken';
import { auth } from '../../../auth';
import { logger } from '../utils/logger';

export async function authMiddleware(
  req: Request,
  res: Response,
  next: NextFunction
): Promise<void> {
  try {
    const token = req.headers.authorization?.replace('Bearer ', '');
    
    if (!token) {
      res.status(401).json({ success: false, error: 'Unauthorized' });
      return;
    }

    // Validar formato JWT
    const parts = token.split('.');
    if (parts.length !== 3) {
      res.status(401).json({ success: false, error: 'Invalid token format' });
      return;
    }

    // Verificar token
    const session = await auth.api.getSession({ headers: req.headers });
    
    if (!session || !session.user) {
      res.status(401).json({ success: false, error: 'Invalid session' });
      return;
    }

    req.userId = session.user.id;
    req.userRole = session.user.role;
    next();
  } catch (error) {
    logger.error('Auth middleware error:', error);
    res.status(401).json({ success: false, error: 'Unauthorized' });
  }
}

// ✅ middleware/tenant.middleware.ts
export function tenantMiddleware(
  req: Request,
  res: Response,
  next: NextFunction
): void {
  const tenantId = req.headers['x-tenant-id'] || req.subdomain || req.hostname.split('.')[0];
  
  if (!tenantId) {
    res.status(400).json({ success: false, error: 'Tenant ID required' });
    return;
  }

  req.tenantId = tenantId;
  next();
}

// ✅ middleware/validation.middleware.ts
import { body, validationResult } from 'express-validator';
import { Request, Response, NextFunction } from 'express';

export const validateCreateUser = [
  body('email')
    .isEmail()
    .withMessage('Invalid email format')
    .normalizeEmail()
    .isLength({ min: 5, max: 255 })
    .custom((value) => {
      const dangerous = /[<>'"&]|script|javascript|on\w+\s*=/i;
      if (dangerous.test(value)) {
        throw new Error('Email contains invalid characters');
      }
      return true;
    }),
  
  body('name')
    .trim()
    .isLength({ min: 2, max: 100 })
    .withMessage('Name must be between 2 and 100 characters'),
  
  body('password')
    .isLength({ min: 8 })
    .withMessage('Password must be at least 8 characters')
    .matches(/^(?=.*[a-z])(?=.*[A-Z])(?=.*\d)/)
    .withMessage('Password must contain uppercase, lowercase and number'),

  (req: Request, res: Response, next: NextFunction) => {
    const errors = validationResult(req);
    if (!errors.isEmpty()) {
      return res.status(400).json({
        success: false,
        errors: errors.array()
      });
    }
    next();
  }
];
```

### Error Handling

```typescript
// ✅ middleware/errorHandler.ts
import { Request, Response, NextFunction } from 'express';
import { logger } from '../utils/logger';

export class AppError extends Error {
  statusCode: number;
  isOperational: boolean;

  constructor(message: string, statusCode: number = 500, isOperational: boolean = true) {
    super(message);
    this.statusCode = statusCode;
    this.isOperational = isOperational;
    Error.captureStackTrace(this, this.constructor);
  }
}

export function errorHandler(
  err: Error | AppError,
  req: Request,
  res: Response,
  next: NextFunction
): void {
  const statusCode = err instanceof AppError ? err.statusCode : 500;
  const isOperational = err instanceof AppError ? err.isOperational : false;

  // Log erro
  logger.error('Error:', {
    message: err.message,
    stack: err.stack,
    url: req.url,
    method: req.method,
    ip: req.ip
  });

  // Resposta baseada no ambiente
  if (process.env.NODE_ENV === 'production') {
    res.status(statusCode).json({
      success: false,
      error: isOperational ? err.message : 'Internal server error'
    });
  } else {
    res.status(statusCode).json({
      success: false,
      error: err.message,
      stack: err.stack
    });
  }
}
```

### Logging Estruturado

```typescript
// ✅ utils/logger.ts
import winston from 'winston';

export const logger = winston.createLogger({
  level: process.env.LOG_LEVEL || 'info',
  format: winston.format.combine(
    winston.format.timestamp(),
    winston.format.errors({ stack: true }),
    winston.format.json()
  ),
  transports: [
    new winston.transports.File({ filename: 'logs/error.log', level: 'error' }),
    new winston.transports.File({ filename: 'logs/combined.log' }),
  ],
});

if (process.env.NODE_ENV !== 'production') {
  logger.add(new winston.transports.Console({
    format: winston.format.simple()
  }));
}

// ✅ Uso correto de logging
logger.info('User created', { userId: user.id, tenantId });
logger.error('Failed to create user', { error: err.message, email });
logger.warn('Rate limit exceeded', { ip: req.ip, endpoint: req.path });
```

## Exceções

- Services muito simples podem conter lógica inline
- Logs sensíveis podem ser sanitizados antes de salvar
- Cache pode ser desabilitado para queries raras

## Verificação

- ✅ Lógica de negócio está em services
- ✅ Todas as rotas têm middlewares apropriados
- ✅ Validação está em todos os inputs
- ✅ Error handling centralizado
- ✅ Logs estruturados
- ✅ Cache com padrão `fitos:namespace:key`

## Recursos Relacionados

- [Database Rules](./database.mdc)
- [Security](./security.mdc)
- [Error Handling](./error-handling.mdc)
- [API Design](./api-design.mdc)
- [Multi-Tenant](./multi-tenant.mdc)
