---
alwaysApply: true
description: Padrões de performance, cache Redis, otimizações e otimização de bundle
---

# Performance

## Propósito

Estabelecer padrões de performance para garantir aplicação rápida, responsiva e eficiente.

## Regras Obrigatórias

### ✅ SEMPRE Fazer

- Usar Redis cache para queries frequentes
- Configurar TTLs específicos por tipo de dado
- Usar Next.js Image Optimization
- Implementar code splitting automático
- Lazy loading para componentes pesados
- Debounce em buscas e inputs
- Otimizar bundle size
- Cache com padrão `fitos:namespace:key`
- CDN para assets estáticos
- Índices de banco para queries frequentes

### ❌ NUNCA Fazer

- NÃO fazer queries N+1
- NÃO re-fetchar dados já em cache
- NÃO carregar toda a biblioteca quando precisa de uma função
- NÃO omitir loading states
- NÃO carregar imagens em tamanho original
- NÃO fazer requests desnecessários

## Padrões e Exemplos

### Redis Cache

```typescript
// ✅ Padrão de cache: fitos:namespace:key
// config/redis.cache.ts
import Redis from 'ioredis';

export class CacheService {
  private redis: Redis;
  private readonly prefix = 'fitos:';

  constructor() {
    this.redis = new Redis(process.env.REDIS_URL!);
  }

  async get<T>(namespace: string, key: string): Promise<T | null> {
    const fullKey = `${this.prefix}${namespace}:${key}`;
    const cached = await this.redis.get(fullKey);
    return cached ? JSON.parse(cached) : null;
  }

  async set(
    namespace: string,
    key: string,
    value: any,
    ttl?: number
  ): Promise<void> {
    const fullKey = `${this.prefix}${namespace}:${key}`;
    if (ttl) {
      await this.redis.setex(fullKey, ttl, JSON.stringify(value));
    } else {
      await this.redis.set(fullKey, JSON.stringify(value));
    }
  }

  async del(namespace: string, pattern: string): Promise<void> {
    const fullPattern = `${this.prefix}${namespace}:${pattern}`;
    const keys = await this.redis.keys(fullPattern);
    if (keys.length > 0) {
      await this.redis.del(...keys);
    }
  }
}

// ✅ Uso em services
export class UserService {
  private cache = new CacheService();

  async getUsers(tenantId: string, options: PaginationOptions) {
    const cacheKey = `${tenantId}:${options.page}:${options.limit}`;
    
    // Tentar cache
    const cached = await this.cache.get<User[]>('users', cacheKey);
    if (cached) return cached;

    // Buscar do banco
    const users = await prisma.user.findMany({
      where: { tenantId },
      skip: (options.page - 1) * options.limit,
      take: options.limit
    });

    // Cache com TTL de 5 minutos
    await this.cache.set('users', cacheKey, users, 300);
    
    return users;
  }
}
```

### TTLs Específicos

```typescript
// ✅ TTLs por tipo de dado
const CACHE_TTL = {
  // Dados que mudam pouco
  PLANS: 3600,           // 1 hora
  CONFIG: 7200,          // 2 horas
  
  // Dados que mudam com frequência
  USERS: 300,            // 5 minutos
  DASHBOARD: 60,         // 1 minuto
  
  // Queries pesadas
  REPORTS: 1800,         // 30 minutos
  
  // Sessions
  SESSION: 86400         // 24 horas
};

await this.cache.set('users', key, users, CACHE_TTL.USERS);
await this.cache.set('plans', key, plans, CACHE_TTL.PLANS);
```

### Next.js Image Optimization

```typescript
// ✅ Usar next/image para otimização
import Image from 'next/image';

export function UserAvatar({ src, alt }) {
  return (
    <Image
      src={src}
      alt={alt}
      width={100}
      height={100}
      loading="lazy"
      placeholder="blur"
      blurDataURL="data:image/jpeg;base64,..."
    />
  );
}

// ❌ ERRADO - img tag normal
<img src={avatar} alt={name} />  // Sem otimização!
```

### Code Splitting

```typescript
// ✅ Lazy loading de componentes
import dynamic from 'next/dynamic';

// Componente pesado - carregar sob demanda
const Chart = dynamic(() => import('@/components/chart'), {
  loading: () => <Skeleton />,
  ssr: false
});

// Componente com peso significativo
const PDFViewer = dynamic(() => import('@/components/pdf-viewer'), {
  loading: () => <div>Carregando PDF...</div>
});

// ✅ Uso condicional
{showChart && <Chart data={data} />}
```

### Debounce em Buscas

```typescript
// ✅ Implementar debounce em buscas
'use client';

import { useDebouncedValue } from '@/hooks/use-debounced-value';

export function UserSearch() {
  const [search, setSearch] = useState('');
  const debouncedSearch = useDebouncedValue(search, 500);
  
  const { data } = useSWR(
    debouncedSearch ? `/api/users?search=${debouncedSearch}` : null,
    fetcher
  );
  
  return (
    <Input
      value={search}
      onChange={(e) => setSearch(e.target.value)}
      placeholder="Buscar usuários..."
    />
  );
}

// ✅ Hook de debounce
import { useEffect, useState } from 'react';

export function useDebouncedValue<T>(value: T, delay: number): T {
  const [debouncedValue, setDebouncedValue] = useState<T>(value);

  useEffect(() => {
    const handler = setTimeout(() => {
      setDebouncedValue(value);
    }, delay);

    return () => clearTimeout(handler);
  }, [value, delay]);

  return debouncedValue;
}
```

### Bundle Size Optimization

```typescript
// ✅ Importar apenas o necessário
import { User } from 'lucide-react';  // ✅ CORRETO
import * as LucideIcons from 'lucide-react';  // ❌ ERRADO - importa tudo

// ✅ Tree-shaking friendly
export { User } from './user';  // ✅ CORRETO
export * from './users';  // ⚠️ Cuidado - pode importar muito

// ✅ Dynamic imports para bibliotecas pesadas
const PDFLib = await import('pdf-lib');  // Carregar sob demanda
```

### Database Indexes

```prisma
// ✅ Criar indexes para queries frequentes
model User {
  id        String   @id @default(uuid())
  email     String   @unique
  tenantId  String
  role      String
  active    Boolean  @default(true)
  
  @@index([tenantId])           // Queries por tenant
  @@index([tenantId, role])     // Queries combinadas
  @@index([tenantId, active])   // Queries filtradas
  @@index([email])              // Login lookup
}
```

### Evitar N+1 Queries

```typescript
// ❌ ERRADO - N+1 queries
const users = await prisma.user.findMany();
for (const user of users) {
  const profile = await prisma.profile.findUnique({
    where: { userId: user.id }
  });  // Query por cada usuário!
}

// ✅ CORRETO - Include ou join
const users = await prisma.user.findMany({
  include: {
    profile: true  // Uma query com join
  }
});
```

### Loading States

```typescript
// ✅ Loading states eficientes
export function UsersList() {
  const { users, isLoading } = useUsers();
  
  if (isLoading) {
    return (
      <div className="space-y-4">
        {Array(3).fill(0).map((_, i) => (
          <Skeleton key={i} className="h-20 w-full" />
        ))}
      </div>
    );
  }
  
  return (
    <div>
      {users.map(user => (
        <UserCard key={user.id} user={user} />
      ))}
    </div>
  );
}
```

### CDN Configuration

```typescript
// ✅ next.config.js
const nextConfig = {
  images: {
    domains: ['cdn.fitos.com', 'cloudinary.com'],
    loader: 'custom',
    loaderFile: './lib/imageLoader.js'
  },
  
  // Optimize fonts
  optimizeFonts: true,
  
  // Compress
  compress: true,
  
  // Production optimizations
  productionBrowserSourceMaps: false
};
```

## Exceções

- Dados em tempo real podem não ter cache
- Componentes críticos podem ser carregados imediatamente
- Alguns dados podem precisar de cache invalidation manual

## Verificação

- ✅ Cache com padrão correto (`fitos:namespace:key`)
- ✅ TTLs específicos configurados
- ✅ Images otimizadas com next/image
- ✅ Code splitting implementado
- ✅ Debounce em buscas
- ✅ Bundle size otimizado
- ✅ Indexes criados no banco

## Recursos Relacionados

- [Backend Patterns](./backend-patterns.mdc)
- [Frontend Patterns](./frontend-patterns.mdc)
- [Database](./database.mdc)
