---
alwaysApply: true
description: Padrões de design de API RESTful, versionamento, responses e paginação
---

# Design de API

## Propósito

Estabelecer padrões consistentes para design de APIs RESTful, garantindo interfaces previsíveis, bem documentadas e fáceis de usar.

## Regras Obrigatórias

### ✅ SEMPRE Fazer

- Seguir convenções RESTful (GET, POST, PUT, DELETE, PATCH)
- Usar versionamento `/api/v1/` para endpoints públicos
- Retornar status codes HTTP corretos (200, 201, 400, 401, 403, 404, 500)
- Response format padronizado: `{ success, data, error, message }`
- Implementar paginação: `{ items, total, page, limit, hasMore }`
- Filtros via query params com validação
- Documentação Swagger para todos os endpoints
- Headers `X-Tenant-Id` ou subdomain para multi-tenant
- Content-Type apropriado (application/json)
- Error messages claros e úteis

### ❌ NUNCA Fazer

- NÃO misturar verbos HTTP
- NÃO retornar diferentes structures para o mesmo endpoint
- NÃO omitir paginação em listagens
- NÃO retornar stacks de erro em produção
- NÃO fazer versionamento breaking changes sem nova versão
- NÃO aceitar input sem validação
- NÃO expor erros internos ao cliente

## Padrões e Exemplos

### Estrutura de Response Padronizada

```typescript
// ✅ Success Response
{
  success: true,
  data: {
    id: "123",
    name: "John Doe",
    email: "john@example.com"
  },
  message?: "Operation successful"
}

// ✅ Error Response
{
  success: false,
  error: "User not found",
  message?: "The requested user does not exist"
}

// ✅ List Response
{
  success: true,
  data: {
    items: [...],
    total: 150,
    page: 1,
    limit: 20,
    hasMore: true
  }
}
```

### Status Codes HTTP Corretos

```typescript
// ✅ Status codes apropriados
import { Response } from 'express';

// 200 - Success (GET, PUT, PATCH)
res.status(200).json({
  success: true,
  data: user
});

// 201 - Created (POST)
res.status(201).json({
  success: true,
  data: newUser,
  message: 'User created successfully'
});

// 400 - Bad Request (validation errors)
res.status(400).json({
  success: false,
  error: 'Validation failed',
  errors: [
    { field: 'email', message: 'Invalid email format' }
  ]
});

// 401 - Unauthorized (no auth token)
res.status(401).json({
  success: false,
  error: 'Authentication required'
});

// 403 - Forbidden (no permission)
res.status(403).json({
  success: false,
  error: 'Insufficient permissions'
});

// 404 - Not Found
res.status(404).json({
  success: false,
  error: 'Resource not found'
});

// 500 - Internal Server Error
res.status(500).json({
  success: false,
  error: process.env.NODE_ENV === 'production' 
    ? 'Internal server error'
    : err.message
});
```

### RESTful Endpoints

```typescript
// ✅ Estrutura RESTful correta
// GET /api/v1/users - Listar usuários
router.get('/users', async (req, res) => {
  const { page, limit, search, sort } = req.query;
  const users = await userService.getUsers(req.tenantId, {
    page: Number(page) || 1,
    limit: Number(limit) || 20,
    search,
    sort
  });
  
  res.json({
    success: true,
    data: users
  });
});

// GET /api/v1/users/:id - Obter usuário
router.get('/users/:id', async (req, res) => {
  const user = await userService.getUserById(req.params.id, req.tenantId);
  
  if (!user) {
    return res.status(404).json({
      success: false,
      error: 'User not found'
    });
  }
  
  res.json({
    success: true,
    data: user
  });
});

// POST /api/v1/users - Criar usuário
router.post('/users', async (req, res) => {
  try {
    const user = await userService.createUser(req.body, req.tenantId);
    res.status(201).json({
      success: true,
      data: user,
      message: 'User created successfully'
    });
  } catch (error) {
    res.status(400).json({
      success: false,
      error: error.message
    });
  }
});

// PUT /api/v1/users/:id - Atualizar usuário
router.put('/users/:id', async (req, res) => {
  const user = await userService.updateUser(req.params.id, req.body, req.tenantId);
  res.json({
    success: true,
    data: user,
    message: 'User updated successfully'
  });
});

// DELETE /api/v1/users/:id - Deletar usuário (soft delete)
router.delete('/users/:id', async (req, res) => {
  await userService.deleteUser(req.params.id, req.tenantId);
  res.json({
    success: true,
    message: 'User deleted successfully'
  });
});

// ❌ ERRADO - Não seguir RESTful
router.post('/users/:id/delete', ...);  // Usar DELETE /users/:id
router.get('/get-users', ...);          // Usar GET /users
router.post('/update-user/:id', ...);   // Usar PUT /users/:id
```

### Paginação Padronizada

```typescript
// ✅ Paginação consistente
interface PaginatedResponse<T> {
  items: T[];
  total: number;
  page: number;
  limit: number;
  hasMore: boolean;
}

async function getPaginatedUsers(
  tenantId: string,
  options: { page: number; limit: number; search?: string }
): Promise<PaginatedResponse<User>> {
  const skip = (options.page - 1) * options.limit;
  
  const [items, total] = await Promise.all([
    prisma.user.findMany({
      where: {
        tenantId,
        deletedAt: null,
        ...(options.search && {
          OR: [
            { name: { contains: options.search, mode: 'insensitive' } },
            { email: { contains: options.search, mode: 'insensitive' } }
          ]
        })
      },
      skip,
      take: options.limit,
      orderBy: { createdAt: 'desc' }
    }),
    prisma.user.count({
      where: {
        tenantId,
        deletedAt: null,
        ...(options.search && {
          OR: [
            { name: { contains: options.search, mode: 'insensitive' } },
            { email: { contains: options.search, mode: 'insensitive' } }
          ]
        })
      }
    })
  ]);

  const hasMore = skip + items.length < total;

  return {
    items,
    total,
    page: options.page,
    limit: options.limit,
    hasMore
  };
}

// ✅ Response com paginação
res.json({
  success: true,
  data: {
    items,
    total,
    page,
    limit,
    hasMore
  }
});
```

### Query Parameters e Filtros

```typescript
// ✅ Validação de query params
router.get('/users', async (req, res) => {
  const { page, limit, search, role, status } = req.query;
  
  // Validação
  const pageNum = Math.max(1, parseInt(page as string) || 1);
  const limitNum = Math.min(100, Math.max(1, parseInt(limit as string) || 20));
  const searchTerm = search ? String(search).trim() : undefined;
  
  // Construir filtros
  const filters: any = {
    tenantId: req.tenantId,
    deletedAt: null
  };
  
  if (searchTerm) {
    filters.OR = [
      { name: { contains: searchTerm, mode: 'insensitive' } },
      { email: { contains: searchTerm, mode: 'insensitive' } }
    ];
  }
  
  if (role) {
    filters.role = role;
  }
  
  if (status) {
    filters.status = status;
  }
  
  const result = await getPaginatedUsers(req.tenantId, {
    page: pageNum,
    limit: limitNum,
    search: searchTerm
  });
  
  res.json({
    success: true,
    data: result
  });
});

// ✅ Uso: GET /users?page=1&limit=20&search=john&role=admin
```

### Swagger Documentation

```typescript
// ✅ Documentação Swagger
import swaggerJsdoc from 'swagger-jsdoc';
import swaggerUi from 'swagger-ui-express';

const swaggerOptions = {
  definition: {
    openapi: '3.0.0',
    info: {
      title: 'FitOS API',
      version: '1.0.0',
      description: 'API documentation for FitOS'
    },
    servers: [
      {
        url: 'http://localhost:3001/api',
        description: 'Development server'
      },
      {
        url: 'https://api.fitos.com/api',
        description: 'Production server'
      }
    ]
  },
  apis: ['./src/routes/*.ts']
};

const specs = swaggerJsdoc(swaggerOptions);
app.use('/api/docs', swaggerUi.serve, swaggerUi.setup(specs));

/**
 * @swagger
 * /api/v1/users:
 *   get:
 *     summary: List all users
 *     tags: [Users]
 *     security:
 *       - bearerAuth: []
 *     parameters:
 *       - in: query
 *         name: page
 *         schema:
 *           type: integer
 *         description: Page number
 *       - in: query
 *         name: limit
 *         schema:
 *           type: integer
 *         description: Items per page
 *     responses:
 *       200:
 *         description: List of users
 *       401:
 *         description: Unauthorized
 */
router.get('/users', async (req, res) => {
  // ...
});
```

## Exceções

- Endpoints internos podem ter estrutura diferente, mas documentados
- Websockets podem usar formato diferente

## Verificação

- ✅ Status codes HTTP corretos
- ✅ Response format padronizado
- ✅ Paginação implementada
- ✅ Validação de query params
- ✅ Swagger documentation
- ✅ Error messages claros

## Recursos Relacionados

- [Backend Patterns](./backend-patterns.mdc)
- [Security](./security.mdc)
- [Error Handling](./error-handling.mdc)
