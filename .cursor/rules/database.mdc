---
alwaysApply: true
description: Padrões de banco de dados, Prisma, migrações seguras e multi-tenancy
---

# Banco de Dados e Migrações

## Propósito

Estabelecer padrões rigorosos para trabalho com banco de dados, garantindo segurança, integridade de dados e operações seguras, especialmente em produção.

## Regras Obrigatórias

### ✅ SEMPRE Fazer

- Usar PostgreSQL + Prisma ORM para todas as operações de banco
- **SEMPRE** fazer backup antes de qualquer migração (`npm run db:backup`)
- Usar `npm run db:safe-migrate` para migrações seguras com backup automático
- Incluir `tenantId` em todas as queries multi-tenant (obrigatório)
- Usar soft deletes com campo `deletedAt` ao invés de DELETE permanente
- Incluir timestamps automáticos: `createdAt`, `updatedAt`
- Criar indexes para campos usados em WHERE frequentes
- Usar transactions para operações múltiplas relacionadas
- Validar dados antes de inserir no banco
- Usar Prisma Client com TypeScript para type safety

### ❌ NUNCA Fazer

- **NUNCA** executar `prisma migrate reset` em produção
- **NUNCA** fazer `DROP DATABASE` ou `DROP SCHEMA` em produção
- **NUNCA** aplicar migrações sem backup prévio
- **NUNCA** deletar dados sem confirmação e backup
- **NUNCA** fazer queries sem filtrar por `tenantId` em aplicações multi-tenant
- **NUNCA** usar SQL raw sem validação (sempre usar Prisma)
- **NUNCA** esquecer de fechar conexões
- **NUNCA** logar queries com dados sensíveis (senhas, tokens)

## Comandos Seguros vs Perigosos

### ✅ Comandos Seguros

```bash
# Migração segura com backup automático
npm run db:safe-migrate

# Migração em desenvolvimento
npm run migrate:dev

# Migração em produção (usa migrate deploy)
npm run migrate:prod

# Gerar Prisma Client
npm run db:generate

# Fazer backup manual
npm run db:backup

# Prisma Studio (visualização)
npm run db:studio
```

### ❌ Comandos Perigosos (NUNCA em Produção)

```bash
# ❌ PROIBIDO - Apaga TODOS os dados
npm run migrate:reset
npx prisma migrate reset

# ❌ PROIBIDO - Operações destrutivas
DROP DATABASE fitos;
DROP SCHEMA public;

# ❌ PROIBIDO - Sem backup
npx prisma migrate dev --force
```

## Padrões e Exemplos

### Schema Multi-Tenant

```prisma
// ✅ schema.prisma - Modelo com multi-tenancy
model User {
  id        String   @id @default(uuid())
  email     String   @unique
  name      String
  tenantId  String   // OBRIGATÓRIO para multi-tenant
  deletedAt DateTime? // Soft delete
  
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  
  // Relações
  tenant    Tenant   @relation(fields: [tenantId], references: [id])
  
  @@index([tenantId]) // Index para performance
  @@index([email])
}

model Tenant {
  id        String   @id @default(uuid())
  name      String
  domain    String   @unique
  planId    String
  active    Boolean  @default(true)
  
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  
  // Relações
  users     User[]
  members   Member[]
  workouts  Workout[]
  
  @@index([domain])
}
```

### Queries com Tenant Isolation

```typescript
// ✅ SEMPRE incluir tenantId em queries
async function getUserById(userId: string, tenantId: string) {
  return await prisma.user.findFirst({
    where: {
      id: userId,
      tenantId: tenantId,  // OBRIGATÓRIO
      deletedAt: null      // Soft delete check
    }
  });
}

// ✅ Listagem com filtro por tenant
async function getUsers(tenantId: string, options: { page: number, limit: number }) {
  return await prisma.user.findMany({
    where: {
      tenantId,
      deletedAt: null
    },
    skip: (options.page - 1) * options.limit,
    take: options.limit,
    orderBy: { createdAt: 'desc' }
  });
}

// ❌ ERRADO - Query sem tenantId (perigoso!)
async function getUserByIdWrong(userId: string) {
  return await prisma.user.findUnique({
    where: { id: userId }  // SEM tenantId - pode vazar dados entre tenants
  });
}
```

### Soft Deletes

```typescript
// ✅ Usar soft delete ao invés de DELETE
async function deleteUser(id: string, tenantId: string) {
  return await prisma.user.update({
    where: { id, tenantId },
    data: { deletedAt: new Date() }
  });
}

// ✅ Queries devem sempre filtrar deletedAt
async function getAllUsers(tenantId: string) {
  return await prisma.user.findMany({
    where: {
      tenantId,
      deletedAt: null  // Não retornar deletados
    }
  });
}
```

### Transactions

```typescript
// ✅ Usar transactions para operações relacionadas
async function createUserWithMembership(data: CreateUserData) {
  return await prisma.$transaction(async (tx) => {
    // Criar usuário
    const user = await tx.user.create({
      data: {
        ...data.user,
        tenantId: data.tenantId
      }
    });

    // Criar membership
    const membership = await tx.membership.create({
      data: {
        userId: user.id,
        tenantId: data.tenantId,
        planId: data.planId,
        startDate: new Date()
      }
    });

    return { user, membership };
  });
}
```

### Indexes para Performance

```prisma
// ✅ Criar indexes para campos usados em WHERE
model Workout {
  id        String   @id @default(uuid())
  userId    String
  tenantId  String
  date      DateTime
  
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  
  @@index([tenantId])           // Para filtros por tenant
  @@index([userId])             // Para filtros por user
  @@index([tenantId, date])    // Para queries combinadas
}
```

### Migrações Seguras

```bash
# ✅ Processo seguro de migração

# 1. SEMPRE fazer backup primeiro
npm run db:backup

# 2. Testar em desenvolvimento
npm run migrate:dev

# 3. Verificar mudanças
npx prisma migrate status

# 4. Aplicar em produção
npm run migrate:prod

# ✅ Ou usar o comando seguro (faz backup automático)
npm run db:safe-migrate
```

### Backup e Restore

```bash
# Fazer backup manual
npm run db:backup
# Salvo em: src/backend/backups/backup_[timestamp].json

# Restaurar backup específico
npm run db:restore backups/backup_20241201_120000.json

# Verificar backups disponíveis
ls -la src/backend/backups/
```

### Validação de Dados

```typescript
// ✅ Validar dados antes de inserir
async function createUser(data: CreateUserDto, tenantId: string) {
  // Validação de email duplicado
  const existingUser = await prisma.user.findUnique({
    where: { email: data.email }
  });
  
  if (existingUser) {
    throw new Error('Email already exists');
  }
  
  // Validação de tenant
  const tenant = await prisma.tenant.findUnique({
    where: { id: tenantId }
  });
  
  if (!tenant || !tenant.active) {
    throw new Error('Invalid tenant');
  }
  
  // Inserir com dados validados
  return await prisma.user.create({
    data: {
      email: data.email,
      name: data.name,
      password: hashedPassword,
      tenantId
    }
  });
}
```

## Procedimento de Emergência

### Se algo der errado durante migração:

```bash
# 1. PARAR aplicação imediatamente
# 2. VERIFICAR status do banco
npx prisma migrate status

# 3. RESTAURAR do último backup
npm run db:restore backups/backup_[timestamp].json

# 4. INVESTIGAR o problema
# 5. DOCUMENTAR o incidente
```

## Checklist antes de Migração

```bash
# ✅ Checklist OBRIGATÓRIO
- [ ] Confirmei que estou no ambiente correto
- [ ] Criei backup antes da operação
- [ ] Testei em desenvolvimento primeiro
- [ ] Verifiquei que não há comandos destrutivos
- [ ] Informei a equipe sobre a operação
- [ ] Tenho plano de rollback se algo falhar
```

## Exceções

- Desenvolvimento local permite `migrate:reset` para testar
- Seed de desenvolvimento pode usar dados mock
- Reset de banco local pode ser aceito para testes

## Verificação

- ✅ Backup antes de migrações
- ✅ tenantId em todas as queries multi-tenant
- ✅ Soft deletes implementados
- ✅ Transactions para operações relacionadas
- ✅ Indexes criados para performance
- ✅ Validação de dados antes de insert

## Recursos Relacionados

- [Database Safety Guidelines](docs/DATABASE_SAFETY_GUIDELINES.md)
- [Proteção Dados Produção](docs/PROTECAO_DADOS_PRODUCAO.md)
- [Multi-Tenant](./multi-tenant.mdc)
- [Backend Patterns](./backend-patterns.mdc)
- [Security](./security.mdc)
