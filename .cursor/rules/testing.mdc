---
alwaysApply: true
description: Padrões de testes, Jest, Playwright, cobertura e práticas de teste
---

# Testes

## Propósito

Estabelecer padrões para testes garantindo qualidade, cobertura adequada e confiabilidade do código.

## Regras Obrigatórias

### ✅ SEMPRE Fazer

- Usar Jest para testes unitários e integração
- Usar Playwright para testes E2E
- Manter cobertura mínima de 80%
- Testes ao lado do arquivo (`*.test.ts`) ou em `__tests__/`
- Mocks para serviços externos
- Testes de segurança obrigatórios
- Nomes de testes descritivos
- Testes rápidos e independentes
- CI/CD executa todos os testes
- Limpar estado entre testes

### ❌ NUNCA Fazer

- NÃO pular testes falhando
- NÃO testar apenas casos felizes (happy path)
- NÃO criar testes que dependem uns dos outros
- NÃO fazer testes que dependem de ordem específica
- NÃO usar dados de produção para testes
- NÃO omitir cenários de erro

## Padrões e Exemplos

### Testes Unitários (Jest)

```typescript
// ✅ Test unitário completo
// services/user.service.test.ts
import { UserService } from './user.service';
import { PrismaClient } from '@prisma/client';

// Mock Prisma
jest.mock('@prisma/client');

describe('UserService', () => {
  let userService: UserService;
  let mockPrisma: jest.Mocked<PrismaClient>;

  beforeEach(() => {
    mockPrisma = new PrismaClient() as jest.Mocked<PrismaClient>;
    userService = new UserService(mockPrisma);
  });

  afterEach(() => {
    jest.clearAllMocks();
  });

  describe('createUser', () => {
    it('should create a new user successfully', async () => {
      // Arrange
      const userData = {
        email: 'test@example.com',
        name: 'Test User',
        tenantId: 'tenant-123'
      };

      const expectedUser = {
        id: 'user-123',
        ...userData,
        createdAt: new Date(),
        updatedAt: new Date()
      };

      mockPrisma.user.create.mockResolvedValue(expectedUser);

      // Act
      const result = await userService.createUser(userData, 'tenant-123');

      // Assert
      expect(result).toEqual(expectedUser);
      expect(mockPrisma.user.create).toHaveBeenCalledWith({
        data: userData
      });
    });

    it('should throw error when email already exists', async () => {
      // Arrange
      mockPrisma.user.findUnique.mockResolvedValue({
        id: 'existing-user',
        email: 'test@example.com',
        name: 'Existing User',
        tenantId: 'tenant-123'
      });

      // Act & Assert
      await expect(
        userService.createUser({
          email: 'test@example.com',
          name: 'Test User'
        }, 'tenant-123')
      ).rejects.toThrow('Email already exists');
    });
  });
});
```

### Testes de Integração

```typescript
// ✅ Teste de integração
// tests/integration/users.test.ts
import request from 'supertest';
import { app } from '../../src/app';
import { PrismaClient } from '@prisma/client';

const prisma = new PrismaClient();

describe('Users API Integration', () => {
  let authToken: string;
  let tenantId: string;

  beforeAll(async () => {
    // Setup: criar tenant e usuário de teste
    const tenant = await prisma.tenant.create({
      data: {
        name: 'Test Tenant',
        domain: 'test-tenant'
      }
    });
    tenantId = tenant.id;

    // Login para obter token
    const loginRes = await request(app)
      .post('/api/auth/login')
      .send({
        email: 'admin@test.com',
        password: 'password123'
      });
    
    authToken = loginRes.body.token;
  });

  afterAll(async () => {
    // Cleanup
    await prisma.user.deleteMany({});
    await prisma.tenant.deleteMany({});
    await prisma.$disconnect();
  });

  it('should create a new user', async () => {
    const res = await request(app)
      .post('/api/users')
      .set('Authorization', `Bearer ${authToken}`)
      .set('X-Tenant-Id', tenantId)
      .send({
        email: 'newuser@test.com',
        name: 'New User',
        password: 'password123'
      });

    expect(res.status).toBe(201);
    expect(res.body.success).toBe(true);
    expect(res.body.data).toHaveProperty('id');
    expect(res.body.data.email).toBe('newuser@test.com');
  });

  it('should return 400 for invalid email', async () => {
    const res = await request(app)
      .post('/api/users')
      .set('Authorization', `Bearer ${authToken}`)
      .set('X-Tenant-Id', tenantId)
      .send({
        email: 'invalid-email',
        name: 'Test User'
      });

    expect(res.status).toBe(400);
    expect(res.body.success).toBe(false);
  });
});
```

### Testes E2E (Playwright)

```typescript
// ✅ Teste E2E completo
// tests/e2e/login.spec.ts
import { test, expect } from '@playwright/test';

test.describe('Login Flow', () => {
  test.beforeEach(async ({ page }) => {
    await page.goto('/login');
  });

  test('should login successfully with valid credentials', async ({ page }) => {
    // Fill login form
    await page.fill('[data-testid="email-input"]', 'user@example.com');
    await page.fill('[data-testid="password-input"]', 'password123');
    
    // Click login button
    await page.click('[data-testid="login-button"]');
    
    // Wait for redirect
    await page.waitForURL('/dashboard');
    
    // Verify logged in state
    const userMenu = await page.locator('[data-testid="user-menu"]');
    await expect(userMenu).toBeVisible();
  });

  test('should show error for invalid credentials', async ({ page }) => {
    await page.fill('[data-testid="email-input"]', 'invalid@example.com');
    await page.fill('[data-testid="password-input"]', 'wrongpassword');
    await page.click('[data-testid="login-button"]');
    
    // Wait for error message
    const errorMessage = await page.locator('[data-testid="error-message"]');
    await expect(errorMessage).toBeVisible();
    await expect(errorMessage).toContainText('Invalid credentials');
  });

  test('should validate email format', async ({ page }) => {
    await page.fill('[data-testid="email-input"]', 'invalid-email');
    await page.click('[data-testid="login-button"]');
    
    const emailError = await page.locator('[data-testid="email-error"]');
    await expect(emailError).toBeVisible();
    await expect(emailError).toContainText('Invalid email');
  });
});
```

### Testes de Segurança

```typescript
// ✅ Testes de segurança
// tests/security/auth.test.ts
describe('Security Tests', () => {
  it('should reject requests without authentication', async () => {
    const res = await request(app)
      .get('/api/users')
      .send();

    expect(res.status).toBe(401);
  });

  it('should reject SQL injection attempts', async () => {
    const res = await request(app)
      .post('/api/users')
      .set('Authorization', `Bearer ${authToken}`)
      .send({
        email: "' OR '1'='1",
        name: "'; DROP TABLE users; --"
      });

    expect(res.status).toBe(400);
  });

  it('should reject XSS attempts', async () => {
    const res = await request(app)
      .post('/api/users')
      .set('Authorization', `Bearer ${authToken}`)
      .send({
        name: '<script>alert("XSS")</script>'
      });

    expect(res.status).toBe(400);
  });

  it('should enforce rate limiting', async () => {
    const requests = Array(25).fill(null).map(() =>
      request(app)
        .post('/api/auth/login')
        .send({
          email: 'test@example.com',
          password: 'wrongpassword'
        })
    );

    const responses = await Promise.all(requests);
    const lastResponse = responses[responses.length - 1];
    
    expect(lastResponse.status).toBe(429); // Too Many Requests
  });
});
```

### Coverage Reports

```typescript
// ✅ Configuração de cobertura
// jest.config.js
module.exports = {
  collectCoverage: true,
  coverageDirectory: 'coverage',
  coverageThreshold: {
    global: {
      branches: 80,
      functions: 80,
      lines: 80,
      statements: 80
    }
  },
  collectCoverageFrom: [
    'src/**/*.ts',
    '!src/**/*.test.ts',
    '!src/**/*.spec.ts',
    '!src/tests/**/*',
    '!src/index.ts'
  ]
};
```

## Exceções

- Testes E2E podem ser mais lentos
- Alguns testes podem precisar de setup específico
- Testes de performance podem ter thresholds diferentes

## Verificação

- ✅ Cobertura mínima de 80%
- ✅ Todos os testes passando no CI/CD
- ✅ Testes rápidos e independentes
- ✅ Mocks para serviços externos
- ✅ Testes de segurança implementados

## Recursos Relacionados

- [Jest Documentation](https://jestjs.io/)
- [Playwright Documentation](https://playwright.dev/)
- [CI/CD Pipeline](./deployment.mdc)
